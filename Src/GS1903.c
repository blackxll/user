//==========================================================================
// Function Define:
// void F_GS1903_GPIO_Init(void)
// void F_GS1903_1Din_SendData(GPIO_T *port, uint32_t u32PinMask, uint8_t R_DAT)
// void F_GS1903_1Din_SendPort(uint32_t u32PinMask, uint8_t R_DAT)
// void F_GS1903_2Din_SendData(uint8_t R_DAT1, uint8_t R_DAT2)
// void F_GS1903_2Din_SendPort(uint8_t R_DAT1, uint8_t R_DAT2)
// void F_Refresh_GS1903_All_For2Din(void)
// void F_GS1903_5Din_SendData(uint8_t R_DAT1, uint8_t R_DAT2, uint8_t R_DAT3, uint8_t R_DAT4, uint8_t R_DAT5)
// void F_GS1903_5Din_SendPort(uint8_t R_DAT1, uint8_t R_DAT2, uint8_t R_DAT3, uint8_t R_DAT4, uint8_t R_DAT5)
// void F_Refresh_GS1903_All_For5Din(void)
//==========================================================================
#include "Public.h"



//==============================================================================================================
//==============================================================================================================
// GS1903控制处理
//==============================================================================================================
//==============================================================================================================


//==========================================================================
// FUNCTION: GS1903控制引脚DIN初始化
// INPUT:    NONE
// OUTPUT:   NONE
//==========================================================================
void F_GS1903_GPIO_Init(void)
{
	// GS1903 DIN
	GPIO_SetMode(P_GS1903_DIN_GPIO1, C_GS1903_DIN_MASK1, GPIO_PMD_OUTPUT);
	GPIO_ResetBits(P_GS1903_DIN_GPIO1, C_GS1903_DIN_MASK1);
}


//==============================================================================================================
//==============================================================================================================
//==============================================================================================================
//==============================================================================================================


//==========================================================================
// FUNCTION: 单个DIN发送输出数据
// INPUT:    
//			 *port      -- DIN引脚GPIO口
//			 u32PinMask -- DIN引脚位
//			 R_DAT      -- DIN输出数据
// OUTPUT:   NONE
//==========================================================================
void F_GS1903_1Din_SendData(GPIO_T *port, uint32_t u32PinMask, uint8_t R_DAT)
{
	uint8_t i = 0;
	
	while(i < 8)			// 4个指令周期(80ns)
	{
		if(R_DAT & 0x80)	// 6个指令周期(120ns)
		{
			//=================================================
			// DAT = 1, HIGH = 900us, LOW = 300us
			//=================================================
			(port)->DOUT |=  (u32PinMask);	// 5个指令周期(100ns)
			DELAY_40NOP();					// 40个指令周期(800ns)
			(port)->DOUT &= ~(u32PinMask);	// 5个指令周期(100ns)
			//DELAY_15NOP();				// 15个指令周期(300ns)
		}
		else
		{
			//=================================================
			// DAT = 1, HIGH = 300us, LOW = 900us
			//=================================================
			(port)->DOUT |=  (u32PinMask);	// 5个指令周期(100ns)
			DELAY_10NOP();					// 10个指令周期(200ns)
			(port)->DOUT &= ~(u32PinMask);	// 5个指令周期(100ns)
			DELAY_26NOP();					// 26个指令周期(520ns)
		}
		R_DAT <<= 1;	// 2个指令周期(40ns)
		i++;			// 2个指令周期(40ns)
	}
}


//==========================================================================
// FUNCTION: 单个DIN发送引脚必须在一个PORT, 其它引脚可用作其它用途
// INPUT:    
//			 u32PinMask -- DIN引脚位
//			 R_DAT      -- DIN输出数据
// OUTPUT:   NONE
//==========================================================================
void F_GS1903_1Din_SendPort(uint32_t u32PinMask, uint8_t R_DAT)
{
	//=========================================================
	// BIT7
	//=========================================================
	// 码0和码1起始为高电平
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x80))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
	
	//=========================================================
	// BIT6
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_11NOP();								// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x40))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
	
	//=========================================================
	// BIT5
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_11NOP();								// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x20))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
	
	//=========================================================
	// BIT4
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_11NOP();								// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x10))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
	
	//=========================================================
	// BIT3
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_11NOP();								// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x08))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
	
	//=========================================================
	// BIT2
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_11NOP();								// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x04))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
	
	//=========================================================
	// BIT1
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_11NOP();								// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x02))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
	
	//=========================================================
	// BIT0
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_11NOP();								// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = u32PinMask;			// 4个指令周期(80ns)
	//==========================
	// 把码0的电平反转
	DELAY_7NOP();								// 7个指令周期(140ns)
	if(!(R_DAT & 0x01))	P_GS1903_DIN_PORT1 = 0;	// 8个指令周期(160ns)
	//==========================
	// 把码1的电平反转
	DELAY_25NOP();								// 25个指令周期(500ns)
	P_GS1903_DIN_PORT1 = 0;						// 5个指令周期(100ns)
}


//==============================================================================================================
//==============================================================================================================
//==============================================================================================================
//==============================================================================================================

//==========================================================================
// FUNCTION:  2个DIN发送引脚必须在一个PORT, 其它引脚可用作其它用途
// INPUT:    
//			 R_DAT1 -- DIN1引脚发送的数据
//			 R_DAT2 -- DIN2引脚发送的数据
// OUTPUT:   NONE
//==========================================================================
void F_GS1903_2Din_SendData(uint8_t R_DAT1, uint8_t R_DAT2)
{
	uint32_t R_DIN_DAT;
	
	//=========================================================
	// BIT7
	//=========================================================
	// 码0和码1起始为高电平
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x80)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//==========================
	// 把码0的电平反转
	if(R_DAT2 & 0x80)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//==========================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x40)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x40)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_18NOP();										// 18个指令周期(360ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	
	//=========================================================
	// BIT6
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_5NOP();										// 5个指令周期(100ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//=================================
	// 把码0的电平反转
	DELAY_4NOP();										// 4个指令周期(80ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x20)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x20)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_18NOP();										// 18个指令周期(360ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	
	//=========================================================
	// BIT5
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_5NOP();										// 5个指令周期(100ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//=================================
	// 把码0的电平反转
	DELAY_4NOP();											// 4个指令周期(80ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x10)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x10)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_18NOP();										// 18个指令周期(360ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	
	//=========================================================
	// BIT4
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_5NOP();										// 5个指令周期(100ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//=================================
	// 把码0的电平反转
	DELAY_4NOP();										// 4个指令周期(80ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x08)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x08)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_18NOP();										// 18个指令周期(360ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	
	//=========================================================
	// BIT3
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_5NOP();										// 5个指令周期(100ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//=================================
	// 把码0的电平反转
	DELAY_4NOP();										// 4个指令周期(80ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x04)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x04)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_18NOP();										// 18个指令周期(360ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	
	//=========================================================
	// BIT2
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_5NOP();										// 5个指令周期(100ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//=================================
	// 把码0的电平反转
	DELAY_4NOP();										// 4个指令周期(80ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x02)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x02)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_18NOP();										// 18个指令周期(360ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	
	//=========================================================
	// BIT1
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_5NOP();										// 5个指令周期(100ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//=================================
	// 把码0的电平反转
	DELAY_4NOP();										// 4个指令周期(80ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x01)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x01)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_18NOP();										// 18个指令周期(360ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	
	//=========================================================
	// BIT0
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_5NOP();										// 5个指令周期(100ns)
	P_GS1903_DIN_PORT1 |= C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
	//=================================
	// 把码0的电平反转
	DELAY_4NOP();										// 4个指令周期(80ns)
	P_GS1903_DIN_PORT1 = (P_GS1903_DIN_PORT1 & (~C_GS1903_2DIN_MASK)) | R_DIN_DAT;	// 11个指令周期(220ns)
	//=================================
	// 把码1的电平反转
	DELAY_35NOP();										// 35个指令周期(700ns)
	P_GS1903_DIN_PORT1 &= ~C_GS1903_2DIN_MASK;			// 10个指令周期(200ns)
}


//==========================================================================
// FUNCTION: 2个DIN发送引脚必须在一个PORT, 其它引脚只能用作DIN或悬空
// INPUT:    
//			 R_DAT1 -- DIN1引脚发送的数据
//			 R_DAT2 -- DIN2引脚发送的数据
// OUTPUT:   NONE
//==========================================================================
void F_GS1903_2Din_SendPort(uint8_t R_DAT1, uint8_t R_DAT2)
{
	uint32_t R_DIN_DAT;
	
	//=========================================================
	// BIT7
	//=========================================================
	// 码0和码1起始为高电平
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x80)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	if(R_DAT2 & 0x80)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_3NOP();										// 3个指令周期(60ns)
	//DELAY_11NOP();									// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x40)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x40)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_23NOP();										// 23个指令周期(460ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
	
	//=========================================================
	// BIT6
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_10NOP();										// 10个指令周期(200ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	DELAY_11NOP();										// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x20)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x20)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_23NOP();										// 23个指令周期(460ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
	
	//=========================================================
	// BIT5
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_10NOP();										// 10个指令周期(200ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	DELAY_11NOP();										// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x10)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x10)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_23NOP();										// 23个指令周期(460ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
	
	//=========================================================
	// BIT4
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_10NOP();										// 10个指令周期(200ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	DELAY_11NOP();										// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x08)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x08)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_23NOP();										// 23个指令周期(460ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
	
	//=========================================================
	// BIT3
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_10NOP();										// 10个指令周期(200ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	DELAY_11NOP();										// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x04)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x04)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_23NOP();										// 23个指令周期(460ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
	
	//=========================================================
	// BIT2
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_10NOP();										// 10个指令周期(200ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	DELAY_11NOP();										// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x02)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x02)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_23NOP();										// 23个指令周期(460ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
	
	//=========================================================
	// BIT1
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_10NOP();										// 10个指令周期(200ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	DELAY_11NOP();										// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	R_DIN_DAT = 0;										// 1个指令周期(20ns)
	if(R_DAT1 & 0x01)	R_DIN_DAT |= C_GS1903_DIN1_BIT;	// 8个指令周期(160ns)
	if(R_DAT2 & 0x01)	R_DIN_DAT |= C_GS1903_DIN2_BIT;	// 8个指令周期(160ns)
	DELAY_23NOP();										// 23个指令周期(460ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
	
	//=========================================================
	// BIT0
	//=========================================================
	// 码0和码1起始为高电平
	DELAY_10NOP();										// 10个指令周期(200ns)
	P_GS1903_DIN_PORT1 = 0xFF;							// 5个指令周期(100ns)
	//=================================
	// 把码0的电平反转
	DELAY_11NOP();										// 11个指令周期(220ns)
	P_GS1903_DIN_PORT1 = R_DIN_DAT;						// 4个指令周期(80ns)
	//=================================
	// 把码1的电平反转
	DELAY_40NOP();										// 40个指令周期(800ns)
	P_GS1903_DIN_PORT1 = 0x00;							// 5个指令周期(100ns)
}


//==============================================================================================================
//==============================================================================================================
//==============================================================================================================
//==============================================================================================================

#if (SET_FLOW_LED_FLOW_NUM_MAX == N_FLOW_LED_GS1903_NUM_MAX * 3)
//==========================================================================
// FUNCTION: 1条GS1903的DIN控制线同时发送数据
// INPUT:    NONE
// OUTPUT:   NONE
// 备注:     GS1903分别控制3个LED(1个流水单位为1个LED)
//==========================================================================
void F_Refresh_GS1903_All_For1Din(void)
{
	uint16_t j = 0;
	
#if defined(FLOW_LED01_DISP_UPDATA_FOR_CHANGE)
	if(Be_FlowLED01_Disp_Updata())
#endif
	{
		// 清除更新标志
		Clr_FlowLED01_Disp_Updata();
	
		__set_PRIMASK(1);	// 关中断
		while(j < SET_FLOW_LED_FLOW_NUM_MAX)
		{
			F_GS1903_1Din_SendPort(C_GS1903_1DIN_MASK, R_FlowLED01_Disp_Data[j]);
			F_GS1903_1Din_SendPort(C_GS1903_1DIN_MASK, R_FlowLED01_Disp_Data[j+1]);
			F_GS1903_1Din_SendPort(C_GS1903_1DIN_MASK, R_FlowLED01_Disp_Data[j+2]);
			j+=3;
		}
		__set_PRIMASK(0);	// 开中断
	}
	
	//=====================================
	// Updata next time
	if(!Be_FlowLED01_PWM_Time_Updata())		Set_FlowLED01_PWM_Time_Updata();
}


//==========================================================================
// FUNCTION: 2条GS1903的DIN控制线同时发送数据
// INPUT:    NONE
// OUTPUT:   NONE
// 备注:     GS1903分别控制3个LED(1个流水单位为1个LED)
//==========================================================================
void F_Refresh_GS1903_All_For2Din(void)
{
	uint16_t i = 0;
	uint16_t j = 0;
	
#if defined(STAIR_LAMP_DISP_UPDATA_FOR_CHANGE) || defined(FLOW_LED01_DISP_UPDATA_FOR_CHANGE)
	if(Be_StairLamp_Disp_Updata() || Be_FlowLED01_Disp_Updata())
#endif
	{
		// 清除更新标志
		Clr_StairLamp_Disp_Updata();
		Clr_FlowLED01_Disp_Updata();
	
		__set_PRIMASK(1);	// 关中断
		while((i < SET_STAIR_LAMP_FLOW_NUM_MAX) && (j < SET_FLOW_LED_FLOW_NUM_MAX))
		{
			F_GS1903_2Din_SendPort(R_StairLamp_Disp_Data[i], R_FlowLED01_Disp_Data[j]);
			F_GS1903_2Din_SendPort(R_StairLamp_Disp_Data[i], R_FlowLED01_Disp_Data[j+1]);
			F_GS1903_2Din_SendPort(R_StairLamp_Disp_Data[i], R_FlowLED01_Disp_Data[j+2]);
			i++;
			j+=3;
		}
		while(i < SET_STAIR_LAMP_FLOW_NUM_MAX)
		{
			F_GS1903_1Din_SendPort(C_STAIR_DIN_BIT, R_StairLamp_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_STAIR_DIN_BIT, R_StairLamp_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_STAIR_DIN_BIT, R_StairLamp_Disp_Data[i]);
			i++;
		}
		while(j < SET_FLOW_LED_FLOW_NUM_MAX)
		{
			F_GS1903_1Din_SendPort(C_FLOW01_DIN_BIT, R_FlowLED01_Disp_Data[j]);
			F_GS1903_1Din_SendPort(C_FLOW01_DIN_BIT, R_FlowLED01_Disp_Data[j+1]);
			F_GS1903_1Din_SendPort(C_FLOW01_DIN_BIT, R_FlowLED01_Disp_Data[j+2]);
			j+=3;
		}
		__set_PRIMASK(0);	// 开中断
	}
	
	//=====================================
	// Updata next time
	if(!Be_StairLamp_PWM_Time_Updata())		Set_StairLamp_PWM_Time_Updata();
	//=====================================
	// Updata next time
	if(!Be_FlowLED01_PWM_Time_Updata())		Set_FlowLED01_PWM_Time_Updata();
}


//==============================================================================================================
//==============================================================================================================
//==============================================================================================================
//==============================================================================================================


#elif (SET_FLOW_LED_FLOW_NUM_MAX == N_FLOW_LED_GS1903_NUM_MAX)
//==========================================================================
// FUNCTION: 1条GS1903的DIN控制线同时发送数据
// INPUT:    NONE
// OUTPUT:   NONE
// 备注:     GS1903同时控制3个LED(1个流水单位为3个LED)
//==========================================================================
void F_Refresh_GS1903_All_For1Din(void)
{
	uint16_t i = 0;
	
#if defined(FLOW_LED01_DISP_UPDATA_FOR_CHANGE)
	if(Be_FlowLED01_Disp_Updata())
#endif
	{
		// 清除更新标志
		Clr_FlowLED01_Disp_Updata();
	
		__set_PRIMASK(1);	// 关中断
		while(i < SET_FLOW_LED_FLOW_NUM_MAX)
		{
			F_GS1903_1Din_SendPort(C_GS1903_1DIN_MASK, R_FlowLED01_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_GS1903_1DIN_MASK, R_FlowLED01_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_GS1903_1DIN_MASK, R_FlowLED01_Disp_Data[i]);
			i++;
		}
		__set_PRIMASK(0);	// 开中断
	}
	
	//=====================================
	// Updata next time
	if(!Be_FlowLED01_PWM_Time_Updata())		Set_FlowLED01_PWM_Time_Updata();
}


//==========================================================================
// FUNCTION: 2条GS1903的DIN控制线同时发送数据
// INPUT:    NONE
// OUTPUT:   NONE
// 备注:     GS1903同时控制3个LED(1个流水单位为3个LED)
//==========================================================================
void F_Refresh_GS1903_All_For2Din(void)
{
	uint16_t i = 0;
	
#if defined(STAIR_LAMP_DISP_UPDATA_FOR_CHANGE) || defined(FLOW_LED01_DISP_UPDATA_FOR_CHANGE)
	if(Be_StairLamp_Disp_Updata() || Be_FlowLED01_Disp_Updata())
#endif
	{
		// 清除更新标志
		Clr_StairLamp_Disp_Updata();
		Clr_FlowLED01_Disp_Updata();
	
		__set_PRIMASK(1);	// 关中断
		while((i < SET_STAIR_LAMP_FLOW_NUM_MAX) && (i < SET_FLOW_LED_FLOW_NUM_MAX))
		{
			F_GS1903_2Din_SendPort(R_StairLamp_Disp_Data[i], R_FlowLED01_Disp_Data[i]);
			F_GS1903_2Din_SendPort(R_StairLamp_Disp_Data[i], R_FlowLED01_Disp_Data[i]);
			F_GS1903_2Din_SendPort(R_StairLamp_Disp_Data[i], R_FlowLED01_Disp_Data[i]);
			i++;
		}
		while(i < SET_STAIR_LAMP_FLOW_NUM_MAX)
		{
			F_GS1903_1Din_SendPort(C_STAIR_DIN_BIT, R_StairLamp_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_STAIR_DIN_BIT, R_StairLamp_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_STAIR_DIN_BIT, R_StairLamp_Disp_Data[i]);
			i++;
		}
		while(i < SET_FLOW_LED_FLOW_NUM_MAX)
		{
			F_GS1903_1Din_SendPort(C_FLOW01_DIN_BIT, R_FlowLED01_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_FLOW01_DIN_BIT, R_FlowLED01_Disp_Data[i]);
			F_GS1903_1Din_SendPort(C_FLOW01_DIN_BIT, R_FlowLED01_Disp_Data[i]);
			i++;
		}
		__set_PRIMASK(0);	// 开中断
	}
	
	//=====================================
	// Updata next time
	if(!Be_StairLamp_PWM_Time_Updata())		Set_StairLamp_PWM_Time_Updata();
	//=====================================
	// Updata next time
	if(!Be_FlowLED01_PWM_Time_Updata())		Set_FlowLED01_PWM_Time_Updata();
}
#endif

//==============================================================================================================
//==============================================================================================================
//==============================================================================================================
//==============================================================================================================






